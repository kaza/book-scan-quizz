{% extends "base.html" %}

{% block title %}Quizz - My Website{% endblock %}

{% block content %}
    <h1>Welcome to the Quizz Page</h1>
    <p>Press and hold the button to record your answer.</p>

    <div class="text-center my-4">
        <button id="recordButton" class="btn btn-lg btn-success rounded-circle" style="width: 100px; height: 100px;">
            Record
        </button>
    </div>
    <div id="audioVisualization" class="mt-3" style="display: none;">
        <div id="audioMeter" style="width: 0%; height: 20px; background-color: #4CAF50; transition: width 0.1s;"></div>
    </div>
    <div id="processingAnimation" class="mt-3" style="display: none;">
        <div class="spinner"></div>
    </div>
    <div id="recordingFeedback" class="text-center my-2" style="display: none;">
        Recording... <span id="recordingDuration">0</span>s
    </div>
    <div id="processingFeedback" class="text-center my-2" style="display: none;">
        Processing your audio...
    </div>
    <div id="resultContainer" class="mt-4">
        <h3>Result:</h3>
        <p id="resultText"></p>
    </div>


{% endblock %}

{% block extra_js %}
    <style>
        #audioMeter {
            max-width: 100%;
            border-radius: 10px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
    </style>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let startTime;
        let durationInterval;
        let audioContext;
        let analyser;
        let dataArray;
        let animationId;

        const recordButton = document.getElementById('recordButton');
        const recordingFeedback = document.getElementById('recordingFeedback');
        const recordingDuration = document.getElementById('recordingDuration');
        const resultText = document.getElementById('resultText');
        const processingFeedback = document.getElementById('processingFeedback');
        const audioVisualization = document.getElementById('audioVisualization');
        const audioMeter = document.getElementById('audioMeter');
        const processingAnimation = document.getElementById('processingAnimation');

        recordButton.addEventListener('mousedown', startRecording);
        recordButton.addEventListener('mouseup', stopRecording);
        recordButton.addEventListener('mouseleave', stopRecording);

        function disableButton() {
            recordButton.disabled = true;
            recordButton.classList.remove('btn-success', 'btn-danger');
            recordButton.classList.add('btn-secondary');
            recordButton.style.cursor = 'not-allowed';
        }

        function enableButton() {
            recordButton.disabled = false;
            recordButton.classList.remove('btn-secondary');
            recordButton.classList.add('btn-success');
            recordButton.style.cursor = 'pointer';
        }

        function startRecording() {
            if (recordButton.disabled) return;

            audioChunks = [];
            navigator.mediaDevices.getUserMedia({audio: true})
                .then(stream => {
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.start();
                    startTime = Date.now();

                    mediaRecorder.addEventListener("dataavailable", event => {
                        audioChunks.push(event.data);
                    });

                    recordButton.classList.remove('btn-success');
                    recordButton.classList.add('btn-danger');
                    recordingFeedback.style.display = 'block';
                    audioVisualization.style.display = 'block';
                    startDurationCounter();
                    startAudioVisualization(stream);
                });
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                recordButton.classList.remove('btn-danger');
                recordButton.classList.add('btn-success');
                recordingFeedback.style.display = 'none';
                audioVisualization.style.display = 'none';
                stopDurationCounter();
                stopAudioVisualization();

                mediaRecorder.addEventListener("stop", () => {
                    const audioBlob = new Blob(audioChunks, {type: 'audio/wav'});
                    sendAudioToServer(audioBlob);
                });
            }
        }

        function startDurationCounter() {
            recordingDuration.textContent = '0';
            durationInterval = setInterval(() => {
                const duration = Math.floor((Date.now() - startTime) / 1000);
                recordingDuration.textContent = duration;
            }, 1000);
        }

        function stopDurationCounter() {
            clearInterval(durationInterval);
        }

        function startAudioVisualization(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            function updateAudioMeter() {
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((acc, val) => acc + val, 0) / dataArray.length;
                const volume = Math.min(100, Math.max(0, average * 2));
                audioMeter.style.width = `${volume}%`;
                animationId = requestAnimationFrame(updateAudioMeter);
            }

            updateAudioMeter();
        }

        function stopAudioVisualization() {
            if (audioContext) {
                audioContext.close();
            }
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function sendAudioToServer(audioBlob) {
            const formData = new FormData();
            formData.append("audio", audioBlob, "recording.wav");

            resultText.textContent = '';
            processingFeedback.style.display = 'block';
            processingAnimation.style.display = 'block';
            disableButton();

            fetch('/evaluate_audio', {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    processingFeedback.style.display = 'none';
                    processingAnimation.style.display = 'none';
                    resultText.textContent = data.result;
                    enableButton();
                })
                .catch(error => {
                    console.error('Error:', error);
                    processingFeedback.style.display = 'none';
                    processingAnimation.style.display = 'none';
                    resultText.textContent = 'An error occurred while processing the audio.';
                    enableButton();
                });
        }
    </script>
{% endblock %}